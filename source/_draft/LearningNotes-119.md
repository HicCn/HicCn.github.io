---
title: 面试题整理
date: 2025-09-10 22:50:59
tags:
    - 编程
categories:
    - 学习笔记
---
## 前言
整理下八股和回忆下项目细节。

## 如何理解ECS[跳转](https://hiccn.github.io/2022/11/03/LearningNotes-5/)
    首先，我认为ecs是一种框架的范式，翻译过来就是实体，组件和系统，我理解ecs的切入点是流场寻路，我觉得ecs的理念和流场的理念有些类似，他都是期望对所有实体施加一个统一的规则来完成一个具体的任务，在流场中，需要一个目标点，流场的逻辑会构建出完整的向量场，然后实体依照构建出来的向量场移动类比过来，构建向量场与移动可能就可以对应到ecs中system的部分，而实体就是流场中的实体，组件中就包含了实体的目标位置。那么ecs基本上就是将这个思想进一步泛化到更多的业务逻辑上，这样实体表现出什么行为并不是实体自身在控制而是一套统一的系统在控制。我觉得这是ecs的核心思想。但是实际开发的时候，大家的出发点其实是大部一样的，比如我之前在四三九九的时候，当时的大哥也希望推ecs，但他的出发点是对逻辑层进一步解耦出逻辑的部分和数据的部分。包括我还了解到有点项目在推ecs但是是出于
    异步编程的考虑，传统写法里，异步逻辑基本上和实体逻辑耦合在一起，而ECS中实体中的相关逻辑本身就已经分散在各个系统中了，把异步操作从实体里拆出来，交给独立的系统去异步处理，既解耦又安全。
## 如何理解mvc
   mvc最基本的就是视图层，逻辑层和控制层，这个架构范式已经很成熟了，理解成本也更低，包括我自己目前在更新的项目也是用的mvc，我的做法简单点来说，我会有一个linker脚本，这个脚本主要负责来收集预制体上的视图组件并且绑定对应的node脚本，这个node脚本就是广义上的控制器脚本，视图组件就是视图层的部分，这部分通常我们会在进行一次封装，最后由广义的业务框架来决定这个node脚本如何更新视图。
## 如何理解mvvm[跳转](https://hiccn.github.io/2024/05/25/LearningNotes-86/)
    mvvm我的理解就是在mvc的基础上进一步的将控制控制层解耦了，在原先的控制器层和视图层中间插入了一个viewModel层，这样视图组件如何显示都依赖viewModel向组件提供了什么样的数据，这样减轻了原本控制器所承担的职责，对于原先的控制器来说，他事实上即负责了业务的更新，也负责了视图的更新，而mvvm则将这两部分解耦了，视图的更新由viewModel来负责，而业务逻辑的更新则由控制器来负责，这样使得代码的职责更加单一，也使得代码的可维护性更高。
## unity&游戏开发八股
   1.  Awake、Start、OnEnable 之间的区别和联系
       1.  Awake:在脚本实例时执行，无论是否激活都会执行，start:在脚本首次激活时执行，onEnable:在脚本每次激活时都会执行
   2. 什么是协程？协程和多线程的区别是什么？
      1. 线程是操作系统级别的资源，用操作系统调度，协程是应用程序级别的资源，不同的应用可以有不同的实现方式，常见的就是用io操作阻塞代码执行，在Unity中协程的实现就是将逻辑分摊到其他帧中执行，在满足特定条件后在后继帧中执行后续的代码，这样就不会阻塞主线程。对于线程和多线程，多线程是并行的，但是协程实际上是串行的，在更底层上，线程的调度是在操作。在unity，unity并不保证api是线程安全，所以如果在unity需要利用多线程的能力，一般上在子线程上处理计算逻辑，但是我还没见过有哪个项目有这么做，异步就完全够用了。
   3. 异步与协程
      1. 异步是一种编程思想，协程是实现这种思想的工具。
   4. 解释下UniTask
      1. UniTask 作为专为 Unity 优化的第三方库，支持0GC和与mono脚本的生命周期绑定，并且对于unity是线程安全的
   5. FixedUpdate 和 Update 在物理处理中的区别
      1. updata就是每帧调用一次，fixedupdate是固定帧率调用一次，在物理处理中，fixedupdate在物理处理之前调用，所以与物理有关的逻辑应该放在fixedupdate中。
   6. 相机
      1. 透视相机：遵循 “近大远小” 的透视原理，物体距离相机越远，显示越小，能模拟人眼视觉，产生立体感；正交相机：物体大小与距离无关，仅由 “Size” 参数决定（2D 中表现为高度的一半），无透视效果，物体显示为平面大小一致。
      2. 遮挡如何实现：从相机朝目标位置发射射线
   7. 插值函数的使用场景
      1. 插值函数一般用于平滑过渡，比如动画的播放，物体的移动，UI的显示等。
   8. 动画相关
      1. Animator，Animation，Animator Controller，Animation Clip 的定义分别是什么？
      2. Blend Tree
      3. IK
   9. 物理
      1. 射线原理以及性能
## C#八股
   1. C#中值类型和引用类型的区别
      1. 值类型存储在栈中，引用类型存储在堆中，值类型传递时是深拷贝，引用类型赋值时是浅拷贝传递引用。
   2. 什么是GC
      1. GC是内存管理的重要环节，GC会自动回收不再使用的内存，但是GC的回收机制是自动的，高级语言基本上避免主动的进行内存管理。
      2. 常见的导致频繁GC的原因：在Update中大量创建对象，频繁的字符串拼接。
      3. 核心优化手段，对象池与复用
   3. 装箱（Boxing） 和拆箱（Unboxing）
      1. 装箱：值类型转换为引用类型，拆箱：引用类型转换为值类型
         1. 装箱和拆箱会触发内存分配和内存拷贝，导致GC压力增大，性能降低。
      2. C#中将值类型赋值给objcet或者某的接口将触发装箱，将object或者接口赋值给值类型将触发拆箱。
## Lua八股[跳转](https://hiccn.github.io/2024/01/20/LearningNotes-72/)

## C++八股
   1. C++中虚函数和纯虚函数的区别
      1. 虚函数是用于实现多态的，纯虚函数是用于实现抽象类的，纯虚函数必须在派生类中实现，否则派生类也是抽象类。
   2. 智能指针
      1. 为什么容易发生内存泄漏
         1. 忘记释放内存，C++中对象被创建后需要手动的delete，如果忘记delete，那么内存将无法被释放。
         2. 逻辑Bug导致无法无法执行到释放内存的位置
         3. 内存地址传递导致所有权混乱
         4. 容器本身的内存管理策略导致对象不会被删除。
         5. 多线程中更加容易出现。
      2. 智能指针是一种自动管理内存的机制，它可以自动释放不再使用的内存，避免内存泄漏。
      3. 常见的智能指针有shared_ptr，unique_ptr，weak_ptr。
         1. shared_ptr：共享指针，多个shared_ptr可以共享一个对象，当最后一个shared_ptr被销毁时，对象会被自动释放。
            1. 多个对象共同持有一个对象，当最后一个shared_ptr被销毁时，对象会被自动释放。
         2. unique_ptr：独占指针，只能有一个unique_ptr指向一个对象，当unique_ptr被销毁时，对象会被自动释放。
            1. 离开作用域时，unique_ptr会自动释放所管理的对象，因此不需要手动调用delete。
         3. weak_ptr：弱指针，可以指向一个shared_ptr管理的对象，但是不会增加shared_ptr的引用计数，当shared_ptr被销毁时，weak_ptr会被置空。
            1. 与shared_ptr配合使用，用于解决循环引用问题。
## 算法与设计模式八股
   1. 常见的核心思想
      1. 动态规划：将复杂问题拆分成若干重叠的子问题，利用最优子结构来求解整体的最优解。比如a到d的最短路径，可以拆分成a到b，b到c，c到d的最短路径;
      2. 贪心算法：通过局部最优来达到全局最优。
      3. 回溯算法：通过对尝试的回退（尝试求解失败时）逐渐构建问题的解
   2. 设计模式总结
      1. 观察者模式
         1. 针对问题：一个对象改变需要联动多个对象，多个对象之间需要解耦
      2. 策略模式
         1. 针对问题：一个对象有多种行为，并且需要动态切换，比如游戏中的角色有不同的攻击方式，需要动态切换
      3. 工厂模式
         1. 针对问题：一个对象需要根据不同的条件创建不同的实例，比如行为树中需要根据配置实例不同的子节点
      4. 单例模式
         1. 针对问题：一个对象需要全局唯一，比如游戏中的配置表，需要全局唯一
      5. 命令模式
         1. 针对问题：将请求作为一个对象之后，可以通过对请求的管理实现撤销，重做等操作。
      6. 装饰模式
         1. 针对问题：一个对象需要动态添加功能，比如游戏中的角色，需要动态添加buff，或者是通过效果的组合表现成一个新的抽象概念，比如游戏中的NPC，装备了不同的武器，不同的技能就可以表现为不同的职业。
   3. 状态机
      1. 状态机是一种编程范式，用于处理对象在生命周期中可能存在的状态以及状态之间的转换关系，状态机通常由状态、动作和转换条件组成，状态机主要面对的问题就是管理游戏对象的状态，比如进入局内玩法内容时，流程中就区分了预备，运行中和结束的状态。
      2. 状态机面对状态膨胀需要引入层级概念
      3. 一般来说，状态机主要负责状态切换，而状态的行为则由状态机之外的其他逻辑来处理，基本上只有对于一些简单的AI逻辑，才会选择直接实现，因为行为逻辑和状态切换是两块不同的内容，行为逻辑也很容易发生膨胀。
   4. 行为树
      1. 行为树一般是由动作节点组合节点，条件节点和装饰节点组成，动作节点表示一个具体的操作，条件节点表示一个判断条件，装饰节点表示对动作节点的修饰，行为树一般用于处理复杂的逻辑。
      2. 对比状态机直接处理行为，行为树的逻辑就显得更加清晰，并且行为树是通过组合节点来完成动作逻辑的，所以行为树更容易扩展，并且更加灵活。
## 数据结构八股
   1. 常见数据结构
      1. 数组
         1. 数组是一种线性数据结构，它通过索引来访问元素，数组的大小是固定的，一旦创建就不能改变。
         2. 实现：初始化时申请一块固定大小的连续内存（如 int[] arr = new int[10]），元素在内存中依次排列（索引 0 对应首地址，索引 i 对应首地址 + i× 元素大小）。
      2. 链表
         1. 链表是一种线性数据结构，它通过指针来访问元素，链表的长度是可变的，可以在任意位置插入或删除元素。
         2. 实现：每个元素包含数据和指向下一个元素的指针（如 LinkedListNode<int> node = new LinkedListNode<int>(value)）。
      3. 栈
         1. 栈是一种后进先出（LIFO）的数据结构，它只允许在一端进行插入和删除操作。
         2. 实现：使用数组或链表实现，通过指针或索引来追踪栈顶元素（如 Stack<int> stack = new Stack<int>()）。
      4. 队列
         1. 队列是一种先进先出（FIFO）的数据结构，它只允许在一端进行插入操作，在另一端进行删除操作。
         2. 实现：使用数组或链表实现，通过指针或索引来追踪队头和队尾元素（如 Queue<int> queue = new Queue<int>()）。
      5. 哈希表
         1. 通过「哈希函数」将键（key）映射到数组索引，实现 O (1) 级别的查找。
         2. 实现：使用数组实现，通过哈希函数计算键的哈希值，将值存储在对应索引位置（如 Dictionary<int, int> dict = new Dictionary<int, int>()）。
         3. 备注：哈希函数（Hash Function）是一种将任意长度的输入数据（称为 “消息” 或 “键”）通过特定的数学变换，映射为固定长度的输出值（称为 “哈希值”“散列值” 或 “摘要”）的函数。
      6. 树
         1. 树是一种非线性数据结构，它由节点和边组成，每个节点可以有零个或多个子节点，只有一个节点没有父节点，称为根节点。
         2. 实现：使用数组或链表实现，通过指针或索引来追踪节点之间的关系（如 TreeNode<int> node = new TreeNode<int>(value)）。
## Unity 优化
   1. DrawCall是什么
      1. DrawCall是CPU向GPU发生渲染指令的过程，每次DrawCall都会消耗一定的性能，所以减少DrawCall是性能优化的一个重要手段。
   2. DrawCall优化手段（基本上就是对着官方和合批规则进行逐条优化）
      1. 静态合批
      2. 动态合批
         1. 打图集
            1. 每次切换材质或纹理时会产生一次GC，所以尽量减少切换材质或纹理的次数。
         2. 保证scale一致
         3. 重叠的对象也会打断合批，隐藏看不见的对象
      3. GPU 实例化
      4. 默认隐藏节点
      5. 逻辑处理
         1. LOD 根据相机位置切换模型质量
            1. Mipmap
         2. 剔除视口外对象
            1. 视锥剔除
            2. 遮挡剔除
         3. 材质的实例管理，复用材质
      6. 细节处理
         1. 图片资源合并，比如背景和标题合并到一张图中
         2. 删除非必要的Canvas
         3. Mask组件也会打断合批，使用RectMask2D代替
   3. 性能优化（Profiler）
      1. CPU
      2. GPU
      3. 内存
         1. 常见的内存占用过高的情况
            1. 纹理过大&&模型精度过高&&音频资源过大
            2. 代码层面的就是内存泄漏
               1. 如何排查：内存占用持续上升并且GC后不回落
                  1. 常见的代码问题：静态对象的使用，事件只监听未移除，
            3. 代码层面管理策略失误（占比少）
               1. 性能敏感位置大量使用临时变量
               2. 无效缓存
            4. Shader 变体过多
            5. 复杂碰撞体 || 粒子过多 || AB包同时存在的资源过多
   4. Ab包优化
      1. 
## 热更
1. HybridCLR
   1. HybridCLR 是一个基于 Unity 的热更方案，它允许在运行时动态加载和执行 C# 代码，从而实现游戏的热更功能。HybridCLR 使用了 IL2CPP 技术，将 C# 代码编译为 C++ 代码，然后通过动态加载和执行 C++ 代码来实现热更功能。
   2. Il2CPP 是 Unity 引擎的一种编译方式，它可以将 C# 代码编译为 C++ 代码，从而提高游戏的性能。Il2CPP 的编译过程包括将 C# 代码转换为 C++ 代码，然后将 C++ 代码编译为机器码，最后将机器码加载到内存中执行。
      1. 这个过程是静态纯AOT编译的，也就是说，在游戏运行之前，所有的 C# 代码都需要被编译为 C++ 代码，然后才能被加载和执行。
      2. 因为元数据裁剪，所以热更的代码也无法被识别。
   3. 原理
      1. 打包时提取元数据到dll中，运行时注入热更程序集的元数据
      2. 混合执行代码（解释执行+JIT编译）
      3. 实现了与AOT的兼容与交互
   4. 工作流程
      1. 打包阶段：
         1. 将代码拆分为 主包（AOT 代码） 和 热更包（IL 代码）。
         2. 编译主包：用 IL2CPP 编译主包，生成 AOT 原生代码。
         3. 提取热更元数据：从热更包（如 HotUpdate.dll）中提取元数据，生成 metadata.dat。
         4. 输出资源：主包 + 热更包（HotUpdate.dll） + 元数据（metadata.dat） + HybridCLR 运行时库。
      2. 运行阶段：
         1. 启动注入：游戏启动时，HybridCLR 加载并注入热更元数据到 IL2CPP。
         2. 加载热更包：从服务器下载最新的热更包（HotUpdate.dll），加载到内存。
         3. 执行热更代码：通过混合执行引擎（解释 / JIT）执行热更代码，热更代码可正常调用主包 API。
   5. 之前解决热更的难点是什么
      1. 热更方案对比
## 帧同步[跳转](https://hiccn.github.io/2024/07/07/LearningNotes-92/)
   1. 帧同步的原理
## 其他问题
1. 技术选型的思路
   1. 引擎选择
      1. 团队的技术积累
      2. 团队资源积累
      3. 项目需求
         1. 主要运行平台
         2. 画面表现
      4. 生态
   2. 基础的功能支持，要求稳定，可维护即可
      1. 存档 json.net
      2. 定时器 自己实现
         1. 时间轮优化
      3. 事件广播 自己实现
         1. 嵌套广播
      4. 外部配置
         1. Luban
         2. Scriptableobject（Unity）
      5. 多语言
         1. 依赖配置表，自己封装
         2. localization插件
      6. 日志
         1. 支持对日志的管理，自己封装
      7. 网络
         1. 传输层协议
            1. TCP (可靠连接，按序到达)
               1. TcpClient
            2. UDP （不保证按序到达，低延迟）
               1. ENet
               2. Kcp
               3. LiteNetLib
         2. 序列化
            1. ProtoBuf
               1. 二进制格式，体积紧凑（比 JSON 小 30%-50%）
            2. FlatBuffers
               1. 二进制格式，零拷贝（序列化后的数据可直接内存访问，无需解析）
               2. 数据结构修改成本高，开发体验稍差
            3. Json
               1. 可读性强
            4. 自定义序列化
         3. 完整的通信框架
            1. Mirror
            2. Netcode
      8. 热更
         1. HybridCLR <span class="heimu">没理由不选的一集</span>
            1. 原生C#热更开发 
               1. 提前划分程序集
               2. 完整支持C#特性
            2. 高性能
         2. XLua
            1. Lua无感热更开发
            2. 需要虚拟机
            3. 适合多语言团队
               1. 策划写代码之类的
         3. ILRuntime
            1. C#有感热更开发开发 
               1. 泛型使用受限
            2. 接入成本低，适合项目早期临时使用
            3. 性能中等
            4. 兼容问题多
         4. InjectFix
            1. 支持函数级替换
            2. 不支持构造函数、泛型方法、新增字段等复杂场景
      9. 资源管理
         1.  技术选型
             1. AssetBundle
                1. Unity 早期推出的底层资源打包系统，将模型、纹理、预制体等资源压缩打包成独立的二进制文件（.bundle），可脱离安装包单独加载，是资源热更新的基础工具。
             2. AssetDatabase
                1. 基于 AB 包封装，通过 “资源地址” 替代路径加载，自动处理依赖和热更新，大幅降低开发成本。
             3. Resource (全部在内存中，没后续操作)
         2.  分包策略
             1.  按功能模块划分
             2.  按生命周期划分
         3. 资源嵌套优化
            1. 分析嵌套
            2. 抽公共模块
         4. 加载与卸载策略
            1. 设立阈值按需加载
         5. 资源压缩
            1. 压缩内存，优化加载速度
      10. 接外部SDK
      11. 打包
   3. 业务架构 （根据需求混合）
      1. MVC
      2. ECS
      3. MVVM
      4. 其他
## 结语
持续整理中。。。
<span class="heimu">密码的八股能不能放过我这一次 /_ \</span>